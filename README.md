# Heroes Battle - Реализация алгоритмов

Проект содержит реализацию четырех ключевых алгоритмов для пошаговой стратегии Heroes Battle.

## Реализованные алгоритмы

### 1. GeneratePresetImpl - Генерация оптимальной армии противника

**Класс:** `GeneratePresetImpl`  
**Метод:** `generate(List<Unit> unitList, int maxPoints)`

#### Описание алгоритма
Реализован жадный алгоритм для формирования оптимальной армии компьютера с учетом следующих критериев:
- Максимальное соотношение атаки к стоимости (приоритет 1)
- Максимальное соотношение здоровья к стоимости (приоритет 2)
- Ограничение: максимум 11 юнитов каждого типа
- Ограничение: суммарная стоимость не превышает maxPoints (1500)

#### Алгоритмическая сложность

**Требуемая сложность:** O(T × N) или лучше, где:
- T — количество типов юнитов
- N — максимальное количество юнитов в армии

**Реализованная сложность:** O(T × N)

**Доказательство:**
1. Создание списка информации о типах юнитов: O(T)
2. Сортировка типов по эффективности: O(T × log(T)) ≈ O(T), так как T обычно мало (4 типа)
3. Жадный алгоритм добавления юнитов:
   - Внешний цикл выполняется максимум N раз (количество юнитов в армии)
   - Внутренний цикл по типам: O(T)
   - Итого: O(T × N)
4. Создание копий юнитов: O(N)

**Итоговая сложность:** O(T) + O(T) + O(T × N) + O(N) = O(T × N)

---

### 2. SimulateBattleImpl - Симуляция пошагового боя

**Класс:** `SimulateBattleImpl`  
**Метод:** `simulate(Army playerArmy, Army computerArmy)`

#### Описание алгоритма
Реализована симуляция боя по раундам с соблюдением следующих правил:
- На каждом раунде юниты сортируются по убыванию атаки
- Юниты атакуют по очереди согласно отсортированному списку
- При гибели юнита во время раунда очередь пересчитывается
- Бой завершается, когда у одной из армий не остается живых юнитов

#### Алгоритмическая сложность

**Требуемая сложность:** O(R × N²) или лучше, где:
- R — количество раундов
- N — общее количество юнитов в обеих армиях

**Реализованная сложность:** O(R × N²)

**Доказательство:**
1. Внешний цикл по раундам: O(R)
2. На каждом раунде:
   - Сбор живых юнитов: O(N)
   - Сортировка по атаке: O(N × log(N))
   - Выполнение ходов:
     - В худшем случае каждый ход может привести к пересчету очереди
     - Метод `attack()` имеет сложность O(N) согласно заданию
     - В худшем случае: O(N) ходов × O(N) на пересчет = O(N²)
   - Удаление погибших: O(N)

**Итоговая сложность:** O(R × (N + N×log(N) + N² + N)) = O(R × N²)

---

### 3. SuitableForAttackUnitsFinderImpl - Определение подходящих целей для атаки

**Класс:** `SuitableForAttackUnitsFinderImpl`  
**Метод:** `getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)`

#### Описание алгоритма
Алгоритм определяет юнитов, доступных для атаки, исключая тех, кто закрыт другими юнитами:
- Для левой армии (компьютер): ищет крайний правый юнит в каждом ряду (не закрыт справа)
- Для правой армии (игрок): ищет крайний левый юнит в каждом ряду (не закрыт слева)

#### Алгоритмическая сложность

**Требуемая сложность:** O(M × R) или лучше, где:
- M — количество юнитов в ряду
- R — количество рядов (фиксировано = 3)

**Реализованная сложность:** O(M × R) = O(M), так как R = 3 (константа)

**Доказательство:**
1. Внешний цикл по рядам: O(R), где R = 3 (фиксировано)
2. Для каждого ряда:
   - Поиск крайнего юнита: O(M), где M — количество юнитов в ряду
3. Добавление в результат: O(R)

**Итоговая сложность:** O(R × M) = O(M × R), что соответствует требованию.  
Так как R = 3 (константа), фактическая сложность O(M), что лучше требуемой.

---

### 4. UnitTargetPathFinderImpl - Поиск кратчайшего пути

**Класс:** `UnitTargetPathFinderImpl`  
**Метод:** `getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)`

#### Описание алгоритма
Реализован алгоритм поиска кратчайшего пути на игровом поле с использованием BFS (Breadth-First Search):
- Учитывает препятствия (другие юниты на поле)
- Поддерживает движение по диагонали (8 направлений)
- Возвращает кратчайший путь в виде списка координат Edge

#### Алгоритмическая сложность

**Требуемая сложность:** O(WIDTH × HEIGHT) или лучше, где:
- WIDTH = 27 (ширина игрового поля)
- HEIGHT = 21 (высота игрового поля)

**Реализованная сложность:** O(WIDTH × HEIGHT)

**Доказательство:**
1. Создание карты занятых клеток: O(N), где N — количество существующих юнитов
   - N ≤ WIDTH × HEIGHT, поэтому O(N) = O(WIDTH × HEIGHT)
2. BFS поиск пути:
   - Каждая клетка посещается максимум один раз
   - Проверка 8 соседей для каждой клетки: O(1)
   - Максимум посещенных клеток: WIDTH × HEIGHT
   - Итого: O(WIDTH × HEIGHT)
3. Восстановление пути: O(длина пути) ≤ O(WIDTH × HEIGHT)

**Итоговая сложность:** O(WIDTH × HEIGHT) + O(WIDTH × HEIGHT) + O(WIDTH × HEIGHT) = O(WIDTH × HEIGHT)

---

## Использованные алгоритмы и структуры данных

- **Жадный алгоритм** (Greedy Algorithm) — для генерации армии
- **BFS** (Breadth-First Search) — для поиска кратчайшего пути
- **Сортировка** — для определения порядка ходов в бою
- **Хеш-таблицы** (HashSet) — для быстрой проверки занятых клеток
- **Очередь** (Queue) — для реализации BFS

